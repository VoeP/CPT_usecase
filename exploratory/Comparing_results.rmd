---
title: "Comparing Results with predicted"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(data.table)
library(here)
library(gridExtra)
library(rlang)
```

## Load Data

```{r}
# Load the Random Forest predictions
# Using here() to locate the file relative to project root
results_df <- read_csv(here("results/predictions_python_models/debug_merged_rf.csv"))

# Preview data
head(results_df)
```

## Plotting Function. The function below plots CPT profiles and can optionally compare true and predicted lithostratigraphic classes side-by-side for each CPT.


```{r}
plot_cpt_series <- function(data,
                            depth_col = "diepte",
                            value_col = "qc",
                            color_var = "lithostrat_id",
                            compare_with = NULL, # New argument for comparison
                            group_var = NULL,
                            facet_var = "sondering_id",
                            title = NULL,
                            depth_label = "Depth below surface (m)",
                            value_label = NULL,
                            ncol_facet = 3,
                            log_value = FALSE,
                            reverse_depth = TRUE,
                            flip_coords = TRUE,
                            alpha_line = 0.7,
                            alpha_point = 0.6,
                            point_size = 0.6,
                            legend_position = "bottom") {
  
  # --- Modification for Comparison ---
  # If compare_with is provided, we reshape the data to plot side-by-side
  if (!is.null(compare_with)) {
    # Check if columns exist
    if (!compare_with %in% names(data)) stop(paste("Column", compare_with, "not found in data"))
    if (!color_var %in% names(data)) stop(paste("Column", color_var, "not found in data"))
    
    # Pivot longer to create a single column for the class value and a type column
    # We use . prefix to avoid name collisions
    data <- data %>%
      pivot_longer(cols = c(all_of(color_var), all_of(compare_with)),
                   names_to = ".classification_type",
                   values_to = ".class_value") %>%
      mutate(.classification_type = factor(.classification_type, 
                                           levels = c(color_var, compare_with),
                                           labels = c("True Class", "Predicted Class")))
    
    # Override the color and facet variables to use the new reshaped columns
    color_var <- ".class_value"
    facet_var <- ".classification_type"
  }
  # -----------------------------------

  depth_sym <- rlang::ensym(depth_col)
  value_sym <- rlang::ensym(value_col)
  
  color_sym <- if (is.null(color_var)) {
    NULL
  } else {
    rlang::ensym(color_var)
  }
  
  group_sym <- if (is.null(group_var) && !is.null(color_var)) {
    rlang::ensym(color_var)
  } else if (is.null(group_var)) {
    rlang::ensym(facet_var)
  } else {
    rlang::ensym(group_var)
  }
  
  value_label <- value_label %||% value_col

  p <- ggplot(data, aes(x = !!depth_sym, y = !!value_sym)) +
    geom_line(aes(group = interaction(!!rlang::enquo(group_sym))), alpha = alpha_line) +
    geom_point(aes(group = interaction(!!rlang::enquo(group_sym))), size = point_size, alpha = alpha_point)

  if (!is.null(color_sym)) {
    p <- p + aes(color = factor(!!color_sym))
  }

  if (log_value) {
    p <- p + scale_y_log10()
  }
  if (reverse_depth) {
    p <- p + scale_x_reverse()
  }
  if (flip_coords) {
    p <- p + coord_flip()
  }

  p +
    facet_wrap(stats::as.formula(paste("~", facet_var)), ncol = ncol_facet) +
    labs(
      title = title %||% sprintf("CPT Profiles (%s vs depth)", value_col),
      x = depth_label,
      y = value_label,
      color = "Class"
    ) +
    theme_minimal() +
    theme(legend.position = legend_position)
}
```

## Generate Comparison Plots

```{r, fig.height=8, fig.width=12}
# A more advanced function to plot layers as shaded rectangles
plot_cpt_with_layers <- function(data, 
                                 value_col, 
                                 class_col, 
                                 title) {

  # 1. Calculate layer boundaries
  layer_boundaries <- data %>%
    group_by(!!rlang::ensym(class_col)) %>%
    summarise(
      min_depth = min(diepte),
      max_depth = max(diepte),
      .groups = 'drop'
    ) %>%
    # Add a mid-point for text labels
    mutate(mid_depth = (min_depth + max_depth) / 2)

  # 2. Create the plot with depth on the x-axis initially
  p <- ggplot(data) +
    # Add shaded rectangles for each layer
    geom_rect(
      data = layer_boundaries,
      aes(
        ymin = -Inf,
        ymax = Inf,
        xmin = min_depth,
        xmax = max_depth,
        fill = !!rlang::ensym(class_col)
      ),
      alpha = 0.1
    ) +
    # Add text labels in the middle of each layer
    # geom_text(
    #   data = layer_boundaries,
    #   aes(y = 0, x = mid_depth, label = !!rlang::ensym(class_col)),
    #   hjust = 0,
    #   size = 3.5,
    #   fontface = "bold"
    # ) +
    # Overlay the CPT data line
    geom_line(aes(y = !!rlang::ensym(value_col), x = diepte), color = "black", size = .2) +
    
    # Theming and labels
    scale_x_reverse() + # Reverse depth axis
    coord_flip() +      # Flip coordinates to make depth the vertical axis
    labs(
      title = title,
      x = "Depth (m)",
      y = toupper(value_col)
    ) +
    theme_minimal() +
    theme(
      legend.position = "none", # Hide legend as labels are on the plot
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    )
  
  return(p)
}

# --- Generate and arrange plots for multiple CPTs ---

# 1. Select 4 random CPTs to plot
set.seed(42) # for reproducibility
sampled_ids <- sample(unique(results_df$sondering_id), 4)

# 2. Loop through IDs, create plot pairs, and add them to a list
plot_list <- list()
for (id in sampled_ids) {
  
  # Filter data for the current CPT
  single_cpt_data <- results_df %>% filter(sondering_id == id)
  
  # Create the "Ground Truth" plot
  plot_true <- plot_cpt_with_layers(
    data = single_cpt_data,
    value_col = "qc",
    class_col = "lithostrat_id",
    title = paste("Sondering", id, "- Truth")
  )
  
  # Create the "Prediction" plot
  plot_pred <- plot_cpt_with_layers(
    data = single_cpt_data,
    value_col = "qc",
    class_col = "pred_class",
    title = paste("Sondering", id, "- Prediction")
  )
  
  # Add the pair of plots to the list
  plot_list <- c(plot_list, list(plot_true, plot_pred))
}

# 3. Arrange all plots in a grid
grid.arrange(grobs = plot_list, ncol = 2)
```


# 2. Generate individual plots
```{r, fig.height=10, fig.width=12}
plot_list <- list()

for (id in sampled_ids) {
  # Filter data for the current ID
  id_data <- results_df %>% filter(sondering_id == id)
  
  # Create the plot using the modified function
  # We compare "lithostrat_id" (True) with "pred_class" (Predicted)
  p <- plot_cpt_series(
    data = id_data,
    value_col = "qc",             # Plotting Cone Resistance
    color_var = "lithostrat_id",  # Original True Class
    compare_with = "pred_class",  # Predicted Class to compare
    title = paste("Sondering:", id),
    ncol_facet = 2                # Display True/Pred side-by-side
  )
  
  plot_list[[as.character(id)]] <- p
}

# 3. Arrange the 4 plots in a grid
# We use grid.arrange to combine the separate ggplot objects
grid.arrange(grobs = plot_list, ncol = 2)
```
